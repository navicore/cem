# factorial.cem - Recursive factorial examples
#
# Cem uses recursion as the primary flow control mechanism, not imperative loops.
# The compiler implements tail-call optimization, so tail-recursive functions
# execute efficiently without growing the call stack.

# TAIL-RECURSIVE FACTORIAL
#
# This is the idiomatic approach in Cem. The factorial-helper function
# maintains an accumulator and makes its recursive call in tail position
# (as the last operation).
#
# : factorial-helper ( n acc -- result )
#   over 1 > if
#     [ over 1 - swap over * factorial-helper ]  # Tail call!
#     [ nip ]  # Return accumulator, discard n
#   ;
#
# : factorial ( n -- n! )
#   1 factorial-helper ;

# SIMPLE RECURSIVE EXAMPLE
#
# Here's a simpler example showing tail recursion: countdown to zero
#
# : countdown ( n -- 0 )
#   dup 0 > if
#     [ 1 - countdown ]  # Tail call!
#     [ ]
#   ;

# For now, a placeholder that returns a constant
# (Full implementation requires stack manipulation words like dup, over, swap, nip)

: simple ( -- Int )
  42 ;
